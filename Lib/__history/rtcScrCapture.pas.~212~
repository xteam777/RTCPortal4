{ Copyright (c) Danijel Tkalcec,
  RealThinClient components - http://www.realthinclient.com }

unit rtcScrCapture;

interface

{$INCLUDE rtcDefs.inc}
{$INCLUDE rtcPortalDefs.inc}

uses
  Windows, Messages, Classes, rtcSystem,
  SysUtils, Graphics, Controls, Forms, //rtcpDesktopHost,
  Execute.DesktopDuplicationAPI, IniFiles,

{$IFDEF DFMirage}
  dfmVideoDriver,
{$ENDIF}
  rtcInfo, rtcLog, rtcZLib, SyncObjs, rtcScrUtils,

  rtcCompress, rtcWinLogon
{$IFDEF KMDriver}
    , MouseAInf
{$ENDIF};

var
  RTC_CAPTUREBLT: DWORD = $40000000;

type
  TRtcCaptureMode=(captureEverything, captureDesktopOnly);
  TRtcMouseControlMode=(eventMouseControl, messageMouseControl);

var
  RtcCaptureMode:TRtcCaptureMode=captureEverything;
  RtcMouseControlMode:TRtcMouseControlMode=messageMouseControl;
  RtcMouseWindowHdl:HWND=0;

type
 TDesktopDuplicationWrapper = class
  const TempBuffLen = 100000;
  private
    FError: HRESULT;
  // D3D11
    FDevice: ID3D11Device;
    FContext: ID3D11DeviceContext;
    FFeatureLevel: TD3D_FEATURE_LEVEL;
  // DGI
    FOutput: TDXGI_OUTPUT_DESC;
    FDuplicate: IDXGIOutputDuplication;
    FTexture: ID3D11Texture2D;
  // update information
   // FMetaData: array of Byte;
    {FMoveRects: PDXGI_OUTDUPL_MOVE_RECT; // array of
    FMoveCount: Integer;
    FDirtyRects: PRECT; // array of
    FDirtyCount: Integer;
     }

   // PixelFormat : TPixelFormat;
    FScreenWidth, FScreenHeight, FBitsPerPixel : Integer;
    FScreenInfoChanged : Boolean;

    FClipRect : TRect;

    FScreenBuff : PByte;

    FChangedRectsCnt : integer;
    FChangedRects : array [0..100000] of TRect;


    TempBuff : array [0..TempBuffLen] of byte;
    // BytesInRow : integer;
    //BitmapP1, BitmapP2 : PByte;
    // FLastChangedX1, FLastChangedY1, FLastChangedX2, FLastChangedY2: Integer;
    //procedure DrawArea(X1, Y1, X2, Y2 : Integer; aPixelFormat: TPixelFormat); //inline;

    function RecieveRects : Boolean;
    procedure CheckScreenInfo(Desc : PD3D11_TEXTURE2D_DESC);

    function GetChangedRect(const RectId : integer) : TRect;
//    procedure SetClipRect(const Rect : TRect);

  public
   // Bitmap: TBitmap;
    //OptimDrawAlg : integer; // 0 - default, 1 - draw algorithm #1, 2 - draw algorithm #2
    constructor Create(var fCreated: Boolean);
    destructor Destroy; override;
    function GetFrame(var fNeedRecreate: Boolean): Boolean;
   // function DrawFrame(var Bitmap: TBitmap; aPixelFormat: TPixelFormat = pf32bit): Boolean;
//    function DrawFrameToDib(pBits: PByte): Boolean;
//    procedure FreeDIB(BitmapInfo: PBitmapInfo;
//      InfoSize: DWORD;
//      Bits: pointer;
//      BitsSize: DWORD);
//    procedure BitmapToDIB(Bitmap: TBitmap;
//      var BitmapInfo: PBitmapInfo;
//      var InfoHeaderSize: DWORD;
//      var Bits: pointer;
//      var ImageSize: DWORD);
    property Error: HRESULT read FError;
  {  property MoveCount: Integer read FMoveCount;
    property MoveRects: PDXGI_OUTDUPL_MOVE_RECT read FMoveRects;
    property DirtyCount: Integer read FDirtyCount;
    property DirtyRects: PRect read FDirtyRects;
    property LastChangedX1: Integer read FLastChangedX1;
    property LastChangedY1: Integer read FLastChangedY1;
    property LastChangedX2: Integer read FLastChangedX2;
    property LastChangedY2: Integer read FLastChangedY2; }
    property ScreenWidth : Integer read FScreenWidth;
    property ScreenHeight : Integer read FScreenHeight;
    property BitsPerPixel : Integer read FBitsPerPixel;
    property ScreenInfoChanged : Boolean read FScreenInfoChanged;

   // property BytesPerPixel : Integer read FBytesPerPixel;
    property ClipRect : TRect read FClipRect write FClipRect;

    property ScreenBuff : PByte read FScreenBuff;
    property ChangedRectsCnt : Integer read FChangedRectsCnt;
    property ChangedRects[const RectId : Integer] : TRect read GetChangedRect;
  end;

implementation

{ TDesktopDuplicationWrapper }

function GetBitsPerPixel(aBitsPerPixel: TPixelFormat): Word;
begin
  case aBitsPerPixel of
    pf1bit: Result := 1;
    pf4bit: Result := 4;
    pf8bit: Result := 8;
    pf15bit: Result := 15;
    pf16bit: Result := 16;
    pf24bit: Result := 24;
    pf32bit: Result := 32;
    else Result := 32;
  end;
end;

constructor TDesktopDuplicationWrapper.Create(var fCreated: Boolean);
var
  GI: IDXGIDevice;
  GA: IDXGIAdapter;
  GO: IDXGIOutput;
  O1: IDXGIOutput1;
begin
  FClipRect := TRect.Create(0, 0, 0, 0);

  fCreated := False;

  fTexture := NIL;

//  Sleep(10000);
  FError := D3D11CreateDevice(
    nil, // Default adapter
    D3D_DRIVER_TYPE_HARDWARE, // A hardware driver, which implements Direct3D features in hardware.
    0,
    Ord(D3D11_CREATE_DEVICE_SINGLETHREADED),
    nil, 0, // default feature
    D3D11_SDK_VERSION,
    FDevice,
    FFeatureLevel,
    FContext
  );
  if Failed(FError) then
  begin
    fCreated := False;
//    xLog('D3D11CreateDevice Error: ' + SysErrorMessage(FError));
    Exit;
  end;

  FError := FDevice.QueryInterface(IID_IDXGIDevice, GI);
  if Failed(FError) then
  begin
    fCreated := False;
//    xLog('QueryInterface IID_IDXGIDevice Error: ' + SysErrorMessage(FError));
    Exit;
  end;

  FError := GI.GetParent(IID_IDXGIAdapter, Pointer(GA));
  if Failed(FError) then
  begin
    fCreated := False;
//    xLog('GI.GetParent Error: ' + SysErrorMessage(FError));
    Exit;
  end;

  FError := GA.EnumOutputs(0, GO);
  if Failed(FError) then
  begin
    fCreated := False;
//    xLog('EnumOutputs Error: ' + SysErrorMessage(FError));
    Exit;
  end;

  FError := GO.GetDesc(FOutput);
  if Failed(FError) then
  begin
    fCreated := False;
//    xLog('GetDesc Error: ' + SysErrorMessage(FError));
    Exit;
  end;

  FError := GO.QueryInterface(IID_IDXGIOutput1, O1);
  if Failed(FError) then
  begin
    fCreated := False;
//    xLog('QueryInterface IID_IDXGIOutput1 Error: ' + SysErrorMessage(FError));
    Exit;
  end;

  FError := O1.DuplicateOutput(FDevice, FDuplicate);
  if Failed(FError) then
  begin
    fCreated := False;
//    xLog('DuplicateOutput Error: ' + SysErrorMessage(FError));
    Exit;
  end;

  fCreated := True;
end;

destructor TDesktopDuplicationWrapper.Destroy;
begin
  inherited;

  if FTexture <> nil then
  begin
    FContext.Unmap(FTexture, 0); //Это нужно?
    FTexture := nil;
    FDuplicate.ReleaseFrame;
  end;

 // if Bitmap <> nil then
  //  Bitmap.Free;
end;

function TDesktopDuplicationWrapper.RecieveRects : Boolean;
var
  i, j, S1, S2, SU, SI : Integer;
  BytesRecieved : UInt;
  RctU, RctI : TRect;
  PMoveRect : PDXGI_OUTDUPL_MOVE_RECT;
  PDirtyRect : PRECT;
begin
  Result := false;
  FError := FDuplicate.GetFrameMoveRects(TempBuffLen,
        PDXGI_OUTDUPL_MOVE_RECT(@TempBuff[0]), BytesRecieved);
  if Failed(FError) then exit;

  FChangedRectsCnt := 0;

  // Получаем MoveRects и зансоим их в FChangeRects
  for i := 0 to BytesRecieved div SizeOf(TDXGI_OUTDUPL_MOVE_RECT) - 1 do
  begin
    PMoveRect := PDXGI_OUTDUPL_MOVE_RECT(@TempBuff[0]) + i;
    FChangedRects[FChangedRectsCnt] := TRect.Create(TPoint.Create(PMoveRect.SourcePoint.X, PMoveRect.SourcePoint.Y),
    PMoveRect.DestinationRect.Right - PMoveRect.DestinationRect.Left,
    PMoveRect.DestinationRect.Bottom - PMoveRect.DestinationRect.Top);
    FChangedRects[FChangedRectsCnt + 1] := TRect.Create(PMoveRect.DestinationRect.Left, PMoveRect.DestinationRect.Top,
    PMoveRect.DestinationRect.Right, PMoveRect.DestinationRect.Bottom);
    Inc(FChangedRectsCnt, 2);
  end;


  // Получаем DirtyRects и зансоим их в FChangeRects
  FDuplicate.GetFrameDirtyRects(TempBuffLen, PRECT(@TempBuff[0]), BytesRecieved);
  if Failed(FError) then Exit;
  for i := 0 to BytesRecieved div SizeOf(TRECT) - 1 do
  begin
    PDirtyRect := PRECT(@TempBuff[0]) + i;
    FChangedRects[FChangedRectsCnt] := TRect.Create(PDirtyRect.Left, PDirtyRect.Top,
      PDirtyRect.Right, PDirtyRect.Bottom);
    Inc(FChangedRectsCnt);
  end;


  // Отсекаем части прямоугольников из ChangedRecs, выходящие за ClipRect
  if (ClipRect.Width <> 0) and (ClipRect.Height <> 0) then
    for i := 0 to FChangedRectsCnt - 1 do
      FChangedRects[i] := TRect.Intersect(FChangedRects[i], ClipRect);


  // Обьеденяем прямоугольники из ChangedRects если их площадь пересечения велика
  for i := 0 to FChangedRectsCnt - 1 do
  begin
    j := i + 1;
    while j < FChangedRectsCnt do
    begin
      RctU := TRect.Union(FChangedRects[i], FChangedRects[j]);
      RctI := TRect.Intersect(FChangedRects[i], FChangedRects[j]);

      S1 := FChangedRects[i].Width * FChangedRects[i].Height;
      S2 := FChangedRects[j].Width * FChangedRects[j].Height;
      SU := RctU.Width * RctU.Height; SI := RctI.Width * RctI.Height;

      if SU - (S1 + S2) > SI then
      begin
        Inc(j);
        continue; // Площадь пересечения двух прямоугольников мала
      end;
          // Площадь пересечения двух прямоугольников велика
          // Заносим в i-ый прямоугольник прямоугольник обьединения i и j
          // j-ый прямоугольник удаляем
      FChangedRects[i] := RctU;

      Move(FChangedRects[j + 1], FChangedRects[j],
        (FChangedRectsCnt - j - 1) * SizeOf(TRect));

      Dec(FChangedRectsCnt);
    end;
  end;
  Result := true;
end;

procedure TDesktopDuplicationWrapper.CheckScreenInfo(Desc: PD3D11_TEXTURE2D_DESC);
var
  NewBitsPerPixel : Integer;
begin
  FScreenInfoChanged := false;

  if FScreenWidth <> Desc.Width then
  begin
    FScreenWidth := Desc.Width;
    FScreenInfoChanged := true;
  end;

  if FScreenHeight <> Desc.Height then
  begin
    FScreenHeight := Desc.Height;
    FScreenInfoChanged := true;
  end;

  case Desc.Format of
    DXGI_FORMAT_R8G8B8A8_TYPELESS,
    DXGI_FORMAT_R8G8B8A8_UNORM,
    DXGI_FORMAT_R8G8B8A8_UNORM_SRGB,
    DXGI_FORMAT_R8G8B8A8_UINT,
    DXGI_FORMAT_R8G8B8A8_SNORM,
    DXGI_FORMAT_R8G8B8A8_SINT,
    DXGI_FORMAT_B8G8R8A8_UNORM,
    DXGI_FORMAT_B8G8R8X8_UNORM,
    DXGI_FORMAT_B8G8R8A8_TYPELESS,
    DXGI_FORMAT_B8G8R8A8_UNORM_SRGB,
    DXGI_FORMAT_B8G8R8X8_TYPELESS,
    DXGI_FORMAT_B8G8R8X8_UNORM_SRGB : NewBitsPerPixel := 32;
  end;
  if FBitsPerPixel <> NewBitsPerPixel then
  begin
    FBitsPerPixel := NewBitsPerPixel;
    FScreenInfoChanged := true;
  end;

end;


function TDesktopDuplicationWrapper.GetFrame(var fNeedRecreate: Boolean): Boolean;
var
  FrameInfo: TDXGI_OUTDUPL_FRAME_INFO;
  DesktopResource: IDXGIResource;
  Desc: TD3D11_TEXTURE2D_DESC;
  Temp: ID3D11Texture2D;
  Resource: TD3D11_MAPPED_SUBRESOURCE;
 // BufLen : Integer;
begin
  Result := False;
  fNeedRecreate := False;

  if FDuplicate = nil then
  begin
    fNeedRecreate := True;
    Exit;
  end
  else
    FDuplicate.ReleaseFrame;

  Sleep(1);

  DesktopResource := nil;

  FError := FDuplicate.AcquireNextFrame(500, FrameInfo, DesktopResource);
  if Failed(FError) then
  begin
//    xLog('AcquireNextFrame Error: ' + SysErrorMessage(FError));
//    if FError = DXGI_ERROR_ACCESS_LOST then
      fNeedRecreate := True;

    Exit;
  end;

  if FTexture <> nil then
    FTexture := nil;

  FError := DesktopResource.QueryInterface(IID_ID3D11Texture2D, FTexture);
  DesktopResource := nil;
  if Failed(FError) then
  begin
//    xLog('QueryInterface.IID_ID3D11Texture2D Error: ' + SysErrorMessage(FError));
    Exit;
  end;

  FTexture.GetDesc(Desc);

  Desc.BindFlags := 0;
  Desc.CPUAccessFlags := Ord(D3D11_CPU_ACCESS_READ) or Ord(D3D11_CPU_ACCESS_WRITE);
  Desc.Usage := D3D11_USAGE_STAGING;
  Desc.MiscFlags := 0;


  //  READ/WRITE texture
  FError := FDevice.CreateTexture2D(@Desc, nil, Temp);
  if Failed(FError) then
  begin
//    xLog('CreateTexture2D Error: ' + SysErrorMessage(FError));
    FTexture := nil;
    FDuplicate.ReleaseFrame;

    Exit;
  end;

  // copy original to the RW texture
  FContext.CopyResource(Temp, FTexture);

  // get texture bits
  FContext.Map(Temp, 0, D3D11_MAP_READ_WRITE, 0, Resource);

  CheckScreenInfo(@Desc);

  if FrameInfo.TotalMetadataBufferSize > 0 then
  begin
    if FScreenInfoChanged then
    begin
      FChangedRectsCnt := 1;
      FChangedRects[0] := TRect.Create(0, 0, FScreenWidth, FScreenHeight);
      if (ClipRect.Width <> 0) and (ClipRect.Height <> 0) then
        FChangedRects[0] := TRect.Intersect(FChangedRects[0], ClipRect);
      Result := true;
    end else Result := RecieveRects;
      {BufLen := FrameInfo.TotalMetadataBufferSize;
      if Length(FMetaData) < BufLen then
        SetLength(FMetaData, BufLen);

      FMoveRects := Pointer(FMetaData);

      FError := FDuplicate.GetFrameMoveRects(BufLen, FMoveRects, BufSize);
      if Failed(FError) then
        Exit;
      FMoveCount := BufSize div sizeof(TDXGI_OUTDUPL_MOVE_RECT);

      FDirtyRects := @FMetaData[BufSize];
      Dec(BufLen, BufSize);

      FError := FDuplicate.GetFrameDirtyRects(BufLen, FDirtyRects, BufSize);
      if Failed(FError) then
        Exit;
      FDirtyCount := BufSize div SizeOf(TRECT);}
  end else
  begin
    FDuplicate.ReleaseFrame;
    exit;
  end;

  FScreenBuff := Resource.pData;

 // Result := true;
end;


function TDesktopDuplicationWrapper.GetChangedRect(const RectId : integer) : TRect;
begin
  Result := FChangedRects[RectId];
end;

  TRtcScreenCapture = class
  private
  //  ScrIn: TRtcScreenEncoder;

   // FFullScreen: boolean;
   // FFixedRegion: TRect;
    ScreenDD : TDesktopDuplicationWrapper;
    ImageCompressionType : Integer;

    FullScreen : boolean;
    FScreenRect : TRect;
    ScrFullRec : TRtcValue1;
    ScrDeltaRec : TRtcValue1;

    //DDACreated: Boolean;

   // FCaptureMask: DWORD;
    FBPPLimit, FMaxTotalSize, FScreen2Delay, FScreenBlockCount,
      FScreen2BlockCount: integer;

    FShiftDown, FCtrlDown, FAltDown: boolean;

    FMouseX, FMouseY, FMouseHotX, FMouseHotY: integer;
    FMouseVisible: boolean;
    FMouseHandle: HICON;
    FMouseIcon: TBitmap;
    FMouseIconMask: TBitmap;
    FMouseShape: integer;

    FMouseChangedShape: boolean;
    FMouseMoved: boolean;
    FMouseLastVisible: boolean;
    FMouseInit: boolean;
    FMouseUser: String;

    FLastMouseUser: String;
    FLastMouseX, FLastMouseY: integer;

    FReduce32bit, FReduce16bit, FLowReduce32bit, FLowReduce16bit: DWORD;

    FLowReduceColors: boolean;
    FLowReduceType: integer;
    FLowReduceColorPercent: integer;

   // FCaptureWidth, FCaptureHeight, FCaptureLeft, FCaptureTop, FScreenWidth,
    //  FScreenHeight, FScreenLeft, FScreenTop: longint;
    FMouseDriver: boolean;

    FMultiMon: boolean;

    //FPDesktopHost: TRtcPDesktopHost;

   // procedure Init;

    function GetBPPLimit: integer;
    procedure SetBPPLimit(const Value: integer);

    function GetMaxTotalSize: integer;
    procedure SetMaxTotalSize(const Value: integer);

     function GetReduce16bit: longword;
    function GetReduce32bit: longword;
    procedure SetReduce16bit(const Value: longword);
    procedure SetReduce32bit(const Value: longword);


    //function GetFullScreen : boolean;
   // procedure SetFullScreen(const Value: boolean);

    function GetScreenRect : TRect;
    procedure SetScreenRect(const Value: TRect);


    procedure Post_MouseDown(Button: TMouseButton);
    procedure Post_MouseUp(Button: TMouseButton);
    procedure Post_MouseMove(X, Y: integer);
    procedure Post_MouseWheel(Wheel: integer);

    procedure keybdevent(key: word; Down: boolean = True);

    procedure SetKeys(capslock, lWithShift, lWithCtrl, lWithAlt: boolean);
    procedure ResetKeys(capslock, lWithShift, lWithCtrl, lWithAlt: boolean);

    procedure SetMouseDriver(const Value: boolean);
    procedure SetMultiMon(const Value: boolean);
    function GetLowReduce16bit: longword;
    function GetLowReduce32bit: longword;
    procedure SetLowReduce16bit(const Value: longword);
    procedure SetLowReduce32bit(const Value: longword);

    function GetLowReduceColors: boolean;
    procedure SetLowReduceColors(const Value: boolean);

    function GetLowReduceColorPercent: integer;
    procedure SetLowReduceColorPercent(const Value: integer);
   // function GetScreenBlockCount: integer;
   // procedure SetScreenBlockCount(const Value: integer);
   // function GetScreen2BlockCount: integer;
  //  procedure SetScreen2BlockCount(const Value: integer);
    function GetScreen2Delay: integer;
    procedure SetScreen2Delay(const Value: integer);
    function GetLowReduceType: integer;
    procedure SetLowReduceType(const Value: integer);

   // function GetHaveScreen: Boolean;
   // procedure SetHaveScreen(const Value: Boolean);
  public
    constructor Create; virtual;
    destructor Destroy; override;

    procedure Clear;
   // function PackScreenImages(Data : RtcByteArray) : Cardinal;
    function GrabScreen: boolean;
    procedure GrabMouse;

    function GetScreen: RtcString;
   // function GetScreenDelta: RtcString;

    function GetMouse: RtcString;
    function GetMouseDelta: RtcString;

    // control events
    procedure MouseDown(const user: String; X, Y: integer;
      Button: TMouseButton);
    procedure MouseUp(const user: String; X, Y: integer; Button: TMouseButton);
    procedure MouseMove(const user: String; X, Y: integer);
    procedure MouseWheel(Wheel: integer);

    procedure KeyPressW(const AText: WideString; AKey: word);
    procedure KeyPress(const AText: RtcString; AKey: word);
    procedure KeyDown(key: word; Shift: TShiftState);
    procedure KeyUp(key: word; Shift: TShiftState);

    procedure SpecialKey(const AKey: RtcString);

    procedure LWinKey(key: word);
    procedure RWinKey(key: word);

    procedure ReleaseAllKeys;

    property BPPLimit: integer read GetBPPLimit write SetBPPLimit default 4;
    property MaxTotalSize: integer read GetMaxTotalSize write SetMaxTotalSize
      default 0;
 //   property ScreenBlockCount: integer read GetScreenBlockCount
 //     write SetScreenBlockCount default 1;
//    property Screen2BlockCount: integer read GetScreen2BlockCount
//      write SetScreen2BlockCount default 1;
    property Screen2Delay: integer read GetScreen2Delay write SetScreen2Delay
      default 0;
   // property FullScreen: boolean read GetFullScreen write SetFullScreen  default True;
    property ScreenRect : TRect read GetScreenRect write SetScreenRect;

    property Reduce16bit: longword read GetReduce16bit write SetReduce16bit;
    property Reduce32bit: longword read GetReduce32bit write SetReduce32bit;
    property LowReduce16bit: longword read GetLowReduce16bit
      write SetLowReduce16bit;
    property LowReduce32bit: longword read GetLowReduce32bit
      write SetLowReduce32bit;
    property LowReducedColors: boolean read GetLowReduceColors
      write SetLowReduceColors;
    property LowReduceType: integer read GetLowReduceType
      write SetLowReduceType;
    property LowReduceColorPercent: integer read GetLowReduceColorPercent
      write SetLowReduceColorPercent;

   // property ScreenWidth: longint read FScreenWidth;
   // property ScreenHeight: longint read FScreenHeight;
   // property ScreenLeft: longint read FScreenLeft;
   // property ScreenTop: longint read FScreenTop;

    property MouseDriver: boolean read FMouseDriver write SetMouseDriver
      default False;
    property MultiMonitor: boolean read FMultiMon write SetMultiMon
      default False;
   // property HaveScreen: Boolean read GetHaveScreen write SetHaveScreen default False;
  end;

function CaptureFullScreen(MultiMon: boolean;
  PixelFormat: TPixelFormat = pf8bit): TBitmap;

implementation

uses Types;
{$IFDEF KMDriver}

var
  FMouseAInit: integer = 0;
{$ENDIF}
  (*
    type
    TMyWinList=class
    cnt:integer;
    list:array[1..1000] of HWnd;
    end;

    function _EnumWindowsProc(Wnd: HWnd; const obj:TMyWinList): Bool; export; stdcall;
    begin
    if (obj.cnt<1000) and IsWindowVisible(Wnd) then
    begin
    if (GetWindowLong(Wnd, GWL_EXSTYLE) and WS_EX_LAYERED) = WS_EX_LAYERED then
    begin
    Inc(obj.cnt);
    obj.list[obj.cnt]:=Wnd;
    end;
    EnumChildWindows(Wnd, @_EnumWindowsProc, longint(obj));
    end;
    Result:=True;
    end;

    function GetLayeredWindowsList:TMyWinList;
    begin
    Result:=TMyWinList.Create;
    Result.cnt:=0;
    EnumDesktopWindows(GetThreadDesktop(Windows.GetCurrentThreadId),@_EnumWindowsProc, Longint(Result));
    end;
  *)

function GetCaptureWindow:HWND;
  var
    h1,h2:HWND;
  begin
  h1 := GetDesktopWindow;
  if (h1<>0) and (RtcCaptureMode=captureDesktopOnly) then
    begin
    h2 := FindWindowEx (h1, 0, 'Progman', 'Program Manager');
    if h2<>0 then h1:=h2;
    end;
  Result:=h1;
  end;

function CaptureFullScreen(MultiMon: boolean;
  PixelFormat: TPixelFormat = pf8bit): TBitmap;
var
  DW: HWND;
  SDC: HDC;
  X, Y: integer;
begin
  SwitchToActiveDesktop;

  Result := TBitmap.Create;
  Result.PixelFormat := PixelFormat;

{$IFDEF MULTIMON}
  if MultiMon then
  begin
    Result.Width := Screen.DesktopWidth;
    Result.Height := Screen.DesktopHeight;
    X := Screen.DesktopLeft;
    Y := Screen.DesktopTop;
  end
  else
{$ENDIF}
  begin
    Result.Width := Screen.Width;
    Result.Height := Screen.Height;
    X := 0;
    Y := 0;
  end;

  Result.Canvas.Lock;
  try
    DW := GetCaptureWindow;
    try
      SDC := GetDC(DW);
    except
      SDC := 0;
    end;
    if (DW <> 0) and (SDC = 0) then
    begin
      DW := 0;
      try
        SDC := GetDC(DW);
      except
        SDC := 0;
      end;
      if SDC = 0 then
        raise Exception.Create('Can not lock on to Desktop Canvas');
    end;
    try
      if not BitBlt(Result.Canvas.Handle, 0, 0, Result.Width, Result.Height,
        SDC, X, Y, SRCCOPY or RTC_CAPTUREBLT) then
      begin
        Result.Free;
        raise Exception.Create('Error capturing screen contents');
      end;
    finally
      ReleaseDC(DW, SDC);
    end;
  finally
    Result.Canvas.Unlock;
  end;
end;

procedure SetDefaultPalette(var Pal: TMaxLogPalette);
var
  i, r, g, b: integer;
  { havepal:boolean;
    Hdl:HWND;
    DC:HDC; }
  procedure SetPal(i, b, g, r: integer);
  begin
    with Pal.palPalEntry[i] do
    begin
      peRed := r;
      peGreen := g;
      peBlue := b;
    end;
  end;

begin
  if Pal.palNumEntries = 16 then
  begin
    { Ignore the disk image of the palette for 16 color bitmaps.
      Replace with the first and last 8 colors of the system palette }
    GetPaletteEntries(SystemPalette16, 0, 8, Pal.palPalEntry[0]);
    GetPaletteEntries(SystemPalette16, 8, 8,
      Pal.palPalEntry[Pal.palNumEntries - 8]);
  end
  else if Pal.palNumEntries = 256 then
  begin
    { Hdl := GetDesktopWindow;
      DC := GetDC(Hdl);
      try
      if (GetDeviceCaps (DC, RASTERCAPS) and RC_PALETTE = RC_PALETTE ) then
      havepal:=GetSystemPaletteEntries ( DC, 0, 256, Pal.palPalEntry )=256
      else
      havepal:=False;
      finally
      ReleaseDC(Hdl,DC);
      end; }

    // if not havepal then
    begin
      SetPal(0, $80, 0, 0);
      SetPal(1, 0, $80, 0);
      SetPal(2, 0, 0, $80);
      SetPal(3, $80, $80, 0);
      SetPal(4, 0, $80, $80);
      SetPal(5, $80, 0, $80);
      i := 6;
      for b := 0 to 4 do
        for r := 0 to 5 do
          for g := 0 to 6 do
          begin
            with Pal.palPalEntry[i] do
            begin
              peBlue := round(b * 255 / 4);
              peRed := round(r * 255 / 5);
              peGreen := round(g * 255 / 6);
            end;
            Inc(i);
          end;
      for r := 1 to 40 do
      begin
        with Pal.palPalEntry[i] do
        begin
          peRed := round(r * 255 / 41);
          peGreen := round(r * 255 / 41);
          peBlue := round(r * 255 / 41);
        end;
        Inc(i);
      end;
    end;
  end;
end;

(*
procedure ByteSwapColors(var Colors; Count: integer);
var // convert RGB to BGR and vice-versa.  TRGBQuad <-> TPaletteEntry
  SysInfo: TSystemInfo;
begin
  GetSystemInfo(SysInfo);
  asm
    MOV   EDX, Colors
    MOV   ECX, Count
    DEC   ECX
    JS    @@END
    LEA   EAX, SysInfo
    CMP   [EAX].TSystemInfo.wProcessorLevel, 3
    JE    @@386
  @@1:  MOV   EAX, [EDX+ECX*4]
    BSWAP EAX
    SHR   EAX,8
    MOV   [EDX+ECX*4],EAX
    DEC   ECX
    JNS   @@1
    JMP   @@END
  @@386:
    PUSH  EBX
  @@2:  XOR   EBX,EBX
    MOV   EAX, [EDX+ECX*4]
    MOV   BH, AL
    MOV   BL, AH
    SHR   EAX,16
    SHL   EBX,8
    MOV   BL, AL
    MOV   [EDX+ECX*4],EBX
    DEC   ECX
    JNS   @@2
    POP   EBX
  @@END:
  end;
end;
*)

function BitmapIsReverse(const Image: TBitmap): boolean;
begin
  With Image do
    if Height < 2 then
      Result := False
    else
      Result := Cardinal(ScanLine[0]) > Cardinal(ScanLine[1]);
end;

function BitmapDataPtr(const Image: TBitmap): pointer;
begin
  With Image do
  begin
    if Height < 2 then
      Result := ScanLine[0]
    else if Cardinal(ScanLine[0]) < Cardinal(ScanLine[1]) then
      Result := ScanLine[0]
    Else
      Result := ScanLine[Height - 1];
  End;
end;

function IsWinNT: boolean;
var
  OS: TOSVersionInfo;
begin
  ZeroMemory(@OS, SizeOf(OS));
  OS.dwOSVersionInfoSize := SizeOf(OS);
  GetVersionEx(OS);
  Result := OS.dwPlatformId = VER_PLATFORM_WIN32_NT;
end;

{ - RtcScreenCapture - }

constructor TRtcScreenCapture.Create;
var
  IniF : TIniFile;
  Flag : boolean;
begin
  inherited;
  FShiftDown := False;
  FCtrlDown := False;
  FAltDown := False;

  FReduce16bit := 0;
  FReduce32bit := 0;
  FLowReduce16bit := 0;
  FLowReduce32bit := 0;
  FLowReduceColors := False;
  FLowReduceType := 0;
  FLowReduceColorPercent := 0;

  FBPPLimit := 4;
  FMaxTotalSize := 0;
  FScreenBlockCount := 1;
  FScreen2BlockCount := 1;
  FScreen2Delay := 0;
  FullScreen := True;
  //FCaptureMask := SRCCOPY;

  //ScrIn := nil;
  FMouseInit := True;
  FLastMouseUser := '';
  FLastMouseX := -1;
  FLastMouseY := -1;
  FMouseX := -1;
  FMouseY := -1;

  IniF := TIniFile.Create(ExtractFilePath(Application.ExeName) + 'Settings.ini');
  ImageCompressionType := IniF.ReadInteger('ScreenCapture', 'ImageCompressionType', 0);
  IniF.Free;

    ScreenDD := TDesktopDuplicationWrapper.Create(Flag);
    if not Flag then // Flag - DDW was created
    begin
      ScreenDD.Free;
      ScreenDD := NIL;
      exit;
    end;

  ScreenData := TRtcValue.Create;

  SwitchToActiveDesktop;
end;

destructor TRtcScreenCapture.Destroy;
begin
  ReleaseAllKeys;

  //f assigned(ScrIn) then
 /// begin
 //   ScrIn.Free;
 //   ScrIn := nil;
 // end;

  if FMouseDriver then
    SetMouseDriver(False);

  inherited;
end;

{
procedure TRtcScreenCapture.Init;
begin
    if not assigned(ScrIn) then
    begin
      InitSize;
      ScrIn := TRtcScreenEncoder.Create;
      ScrIn.Setup(FBPPLimit, FScreenBlockCount, FMaxTotalSize);
      ScrIn.Reduce16bit := FReduce16bit;
      ScrIn.Reduce32bit := FReduce32bit;
      ScrIn.FullScreen := FFullScreen;
      ScrIn.ScreenRect := FScreenRect;
      ScrIn.CaptureMask := FCaptureMask;
      ScrIn.MultiMonitor := FMultiMon;
    end;
end;
 }
{function TRtcScreenCapture.PackScreenImages(Data : RtcByteArray) : Cardinal;
var
  DataPos : PByte;
  ImagePos : PByte;
  RectId, RowId : Integer;
  RowSize, NextRowOfs : Integer;
begin
  DataPos := @Data[0];
  for RectId := 0 to ScreenDD.ChangedRectsCnt - 1 do
    case ImageCompressionType of
      0 : begin // No compression, passing bitmap
            PInteger(DataPos)^ := ScreenDD.ChangedRects[RectId].Width;
            Inc(DataPos, SizeOf(Integer));
            PInteger(DataPos)^ := ScreenDD.ChangedRects[RectId].Height;
            Inc(DataPos, SizeOf(Integer));

            ImagePos :=  ScreenDD.ScreenBuff;
            RowSize := (ScreenDD.ChangedRects[RectId].Width * ScreenDD.BitsPerPixel) shr 3;
            NextRowOfs := ((ScreenRect.Width - ScreenDD.ChangedRects[RectId].Width) * ScreenDD.BitsPerPixel) shr 3;
            for RowId := 0 to ScreenDD.ChangedRects[RectId].Height - 1 do
            begin
              Move(ImagePos, DataPos, RowSize);
              Inc(ImagePos, NextRowOfs);
              Inc(DataPos, RowSize);
            end;
           // Move();
          end;
      1 : begin
          end;
      end;
  Result := Cardinal(DataPos) - Cardinal(@Data[0]);
end;

 }
function TRtcScreenCapture.GrabScreen: boolean;
var
  Flag : boolean;
  PackedImage : RtcByteArray;
  DataPos : PByte;
  ImagePos : PByte;
  RectId, RowId : Integer;
  RowSize, ScreenRowSize : Integer;
begin
 // Init;
  //Result := ScrIn.Capture;
  Result := false;

  if ScreenDD = NIL then
  begin
    ScreenDD := TDesktopDuplicationWrapper.Create(Flag);
    if not Flag then // Flag - DDW was created
    begin
      ScreenDD.Free;
      ScreenDD := NIL;
      exit;
    end;
  end;

  Result := ScreenDD.GetFrame(Flag);
  if Flag then // Flag - DDW was created
  begin
    ScreenDD.Free;
    ScreenDD := NIL;
    exit;
  end;

  //if not Assigned(ScreenData) then
  //   ScreenData := TRtcValue.Create;
  ScreenData.newRecord;
  if ScreenDD.ScreenInfoChanged then
  begin
   // if assigned(Rec) then
    with ScreenData.asRecord.newRecord('res') do//Res.newRecord('res') do
    begin
      asInteger['Width'] := ScreenDD.ScreenWidth;
      asInteger['Height'] := ScreenDD.ScreenHeight;
      asInteger['Bits'] := ScreenDD.BitsPerPixel;
      if FullScreen then FScreenRect := TRect.Create(0, 0,
        ScreenDD.ScreenWidth, ScreenDD.ScreenHeight);
         // asInteger['BytesPerPixel'] := FBytesPerPixel;
    end;
  end;

  // Получили буфер экрана и массив областей с изменениям
  // Запаковываем их и помещаем последовательно в ImageBuff
 // if not Assigned(ScreenData.asRecord) then
  //  begin

  if ScreenDD.ChangedRectsCnt > 0 then
  begin
    with ScreenData.asRecord.newArray('scr') do
    begin
      for RectId := 0 to ScreenDD.ChangedRectsCnt - 1 do
      begin
        SetLength(PackedImage, (ScreenDD.ChangedRects[RectId].Width *
          ScreenDD.ChangedRects[RectId].Height *
          ScreenDD.BitsPerPixel) shr 3);

         case ImageCompressionType of
           0 : begin // No compression, passing bitmap
              ImagePos :=  ScreenDD.ScreenBuff +
                ((ScreenDD.ChangedRects[RectId].Top * ScreenDD.ScreenWidth +
                ScreenDD.ChangedRects[RectId].Left) * ScreenDD.BitsPerPixel) shr 3;
              DataPos := @PackedImage[0];
              RowSize := (ScreenDD.ChangedRects[RectId].Width * ScreenDD.BitsPerPixel) shr 3;
              ScreenRowSize := (ScreenDD.ScreenWidth * ScreenDD.BitsPerPixel) shr 3;
              for RowId := 0 to ScreenDD.ChangedRects[RectId].Height - 1 do
              begin
                Move(ImagePos^, DataPos^, RowSize);
                Inc(ImagePos, ScreenRowSize);
                Inc(DataPos, RowSize);
              end;

           // Move();
            SetLength(PackedImage, RowSize * ScreenDD.ChangedRects[RectId].Height);
            end;
          1 : begin
            end;
         end;

         with newRecord(RectId) do
         begin
           asInteger['Left'] := ScreenDD.ChangedRects[RectId].Left;
           asInteger['Top'] := ScreenDD.ChangedRects[RectId].Top;
           asInteger['Width'] := ScreenDD.ChangedRects[RectId].Width;
           asInteger['Height'] := ScreenDD.ChangedRects[RectId].Height;
           asByteArray['Data'] := PackedImage;
           PackedImage := NIL;
         end;
      end;
    end;
  end;
   {  DWord_Compress_Normal(const NowBlock, DestBlock: pointer;
  const BlockSize: longword): longword;
  case ImageCompressionType of

  end;}

  //ScreenData.newRecord;

  {asInteger['at'] := i * FBlockHeight * FBPPWidth;

  asString['img'] := RtcBytesToString(s);
        if FScreenPalette <> '' then
          Res.asString['pal'] := FScreenPalette;
        FNewScreenPalette := False;
        with Res.newRecord('res') do
        begin
          asInteger['Width'] := FCaptureWidth;
          asInteger['Height'] := FCaptureHeight;
          asInteger['Bits'] := FScreenBPP;
          asInteger['Bytes'] := FBytesPerPixel;
        end;
      end
      else if FNewScreenPalette then
      begin
        if FScreenPalette <> '' then
          Res.asString['pal'] := FScreenPalette;
        FNewScreenPalette := False;
      end;
      Res.asObject['scr'] := Data;
                                        }

   //Res := FInitialScreenData.asRecord;
  {with ScreenData.newRecord do//Res.newRecord('res') do
  begin
    asInteger['Width'] := FScreenRect.Width;
    asInteger['Height'] := FScreenRect.Height;
    asInteger['BitsPerPixel'] := ScreenDD.BitsPerPixel;
         // asInteger['BytesPerPixel'] := FBytesPerPixel;
    asInteger['ChangedRectsCnt'] := ScreenDD.ChangedRectsCnt;
    asByteArray['ChangedRectsData'] := PackedImages;
  end;
   }
        //if FScreenPalette <> '' then
        //  Res.asString['pal'] := FScreenPalette;
        //Res.asObject['scr'] := Data;

end;

function TRtcScreenCapture.GetScreen : RtcString;
var
  Rec : TRtcRecord;
begin
  if ScreenData.isType = rtc_Record then
  begin
    Rec := ScreenData.asRecord;
    if assigned(Rec) then
      Result := Rec.toCode
    else
        Result := '';
  end else
    Result := '';
end;
{
function TRtcScreenCapture.GetScreen: RtcString;
var
  rec: TRtcRecord;
begin
    if ScrIn.GetInitialScreenData.isType = rtc_Record then
    begin
      rec := ScrIn.GetInitialScreenData.asRecord;
      if assigned(rec) then
        Result := rec.toCode
      else
        Result := '';
    end
    else
      Result := '';
end;
}
procedure TRtcScreenCapture.SetMaxTotalSize(const Value: integer);
begin
  if FMaxTotalSize = Value then exit;

 {??????????????????????}
    FMaxTotalSize := Value;
end;

procedure TRtcScreenCapture.SetBPPLimit(const Value: integer);
begin
  if FBPPLimit = Value then exit;

  FBPPLimit := Value;
end;

procedure TRtcScreenCapture.SetScreen2Delay(const Value: integer);
begin
  if FScreen2Delay = Value then exit;

  FScreen2Delay := Value;
end;

procedure TRtcScreenCapture.SetScreenRect(const Value: TRect);
var
  dif: integer;
begin
  FullScreen := (Value.Width = 0) or (Value.Height = 0);

  FScreenRect := Value;
  if (FScreenRect.Right - FScreenRect.Left) mod 4 <> 0 then
  begin
    dif := 4 - ((FScreenRect.Right - FScreenRect.Left) mod 4);
    if FScreenRect.Left - dif >= 0 then
      FScreenRect.Left := FScreenRect.Left - dif
    else
      FScreenRect.Right := FScreenRect.Right + dif;
  end;
  ScreenDD.ClipRect := FScreenRect;
end;
{
procedure TRtcScreenCapture.SetFullScreen(const Value: boolean);
begin
  FullScreen := ;
end;
 }
procedure TRtcScreenCapture.SetMouseDriver(const Value: boolean);
begin
{$IFDEF KMDriver}
  if FMouseDriver <> Value then
  begin
    FMouseDriver := Value;
    if FMouseDriver then
    begin
      if FMouseAInit = 0 then
      begin
        if IsWinNT then
          if MouseAInf.MouseAInit then
            Inc(FMouseAInit);
      end
      else
        Inc(FMouseAInit);
    end
    else if (FMouseAInit > 0) then
    begin
      DEC(FMouseAInit);
      if FMouseAInit = 0 then
        MouseAInf.MouseAUnInit;
    end;
  end;
{$ENDIF}
end;

procedure TRtcScreenCapture.SetReduce16bit(const Value: longword);
begin
  if Value <> FReduce16bit then
  begin
    FReduce16bit := Value;
    end;
end;

procedure TRtcScreenCapture.SetReduce32bit(const Value: longword);
begin
  if Value <> FReduce32bit then
  begin
    FReduce32bit := Value;
   end;
end;

procedure TRtcScreenCapture.SetLowReduce16bit(const Value: longword);
begin
  if Value <> FLowReduce16bit then
  begin
    FLowReduce16bit := Value;
   end;
end;

procedure TRtcScreenCapture.SetLowReduce32bit(const Value: longword);
begin
  if Value <> FLowReduce32bit then
  begin
    FLowReduce32bit := Value;
   end;
end;

procedure TRtcScreenCapture.SetLowReduceColors(const Value: boolean);
begin
  if Value <> FLowReduceColors then
  begin
    FLowReduceColors := Value;
   end;
end;

procedure TRtcScreenCapture.SetLowReduceType(const Value: integer);
begin
  if Value <> FLowReduceType then
  begin
    FLowReduceType := Value;
  end;
end;

procedure TRtcScreenCapture.SetLowReduceColorPercent(const Value: integer);
begin
  if Value <> FLowReduceColorPercent then
  begin
    FLowReduceColorPercent := Value;
  end;
end;

function TRtcScreenCapture.GetScreenRect: TRect;
begin
  Result := ScreenRect;
end;
{
function TRtcScreenCapture.GetFullScreen: boolean;
begin
  Result := FFullScreen;
end;
 }
function TRtcScreenCapture.GetMaxTotalSize: integer;
begin
  Result := FMaxTotalSize;
end;

function TRtcScreenCapture.GetBPPLimit: integer;
begin
  Result := FBPPLimit;
end;

function TRtcScreenCapture.GetScreen2Delay: integer;
begin
  Result := FScreen2Delay;
end;

function TRtcScreenCapture.GetReduce16bit: longword;
begin
  Result := FReduce16bit;
end;

function TRtcScreenCapture.GetReduce32bit: longword;
begin
  Result := FReduce32bit;
end;

function TRtcScreenCapture.GetLowReduce16bit: longword;
begin
  Result := FLowReduce16bit;
end;

function TRtcScreenCapture.GetLowReduce32bit: longword;
begin
  Result := FLowReduce32bit;
end;

function TRtcScreenCapture.GetLowReduceColors: boolean;
begin
  Result := FLowReduceColors;
end;

function TRtcScreenCapture.GetLowReduceType: integer;
begin
  Result := FLowReduceType;
end;

function TRtcScreenCapture.GetLowReduceColorPercent: integer;
begin
  Result := FLowReduceColorPercent;
end;

procedure TRtcScreenCapture.Clear;
begin
  FMouseInit := True;
  ReleaseAllKeys;
end;
{
function ScaleByPixformat(const v: integer; pf: TPixelFormat): integer;
begin
  case pf of
    pf1bit:
      Result := v div 8;
    pf4bit:
      Result := v div 2;
    pf8bit:
      Result := v;
    pf15bit, pf16bit:
      Result := v * 2;
    pf24bit:
      Result := v * 3;
  else
    Result := v * 4;
  end;
end;

function BPPToPixelFormat(a: byte): TPixelFormat;
begin
  case a of
    1:
      Result := pf1bit;
    4:
      Result := pf4bit;
    8:
      Result := pf8bit;
    15:
      Result := pf15bit;
    16:
      Result := pf16bit;
    24:
      Result := pf24bit;
    32:
      Result := pf32bit;
  else
    Result := pf32bit;
  end;
end;
}

{
function TRtcScreenCapture.GetMirageDriver: boolean;
begin
  Result := FMirage;
end;

procedure TRtcScreenCapture.SetMirageDriver(const Value: boolean);
var
  fixed: TRect;
begin
  if FMirage <> Value then
  begin
    FMirage := Value;
    if FMirage then
    begin
      if not assigned(m_BackBm) then
      begin
        Init;
        try
          vd.MultiMonitor := MultiMonitor;
          if not vd.ExistMirrorDriver then
            FMirage := False
          else if vd.IsMirrorDriverActive then
          begin
            vd.DeactivateMirrorDriver;
            Sleep(2000);
            if not vd.ActivateMirrorDriver then
              FMirage := False
            else
            begin
              Sleep(1000);
              vd.MapSharedBuffers;
              FMirage := vd.IsDriverActive;
              if not FMirage then
              begin
                vd.UnMapSharedBuffers;
                vd.DeactivateMirrorDriver;
              end;
            end;
          end
          else if not vd.ActivateMirrorDriver then
            FMirage := False
          else
          begin
            Sleep(1000);
            vd.MapSharedBuffers;
            FMirage := vd.IsDriverActive;
          end;
        except
          FMirage := False;
        end;

        if FMirage then
        begin
          m_Init := True;
          FMouseInit := True;
          m_BackBm := TBitmap.Create;
          m_BackBm.PixelFormat := BPPToPixelFormat(vd.BitsPerPixel);

          if FFullScreen then
          begin }
{IFDEF MULTIMON}{
            if MultiMonitor then
            begin
              FScreenRect.Left := Screen.DesktopRect.Left;
              FScreenRect.Top := Screen.DesktopRect.Top;
              FScreenRect.Right := Screen.DesktopRect.Right;
              FScreenRect.Bottom := Screen.DesktopRect.Bottom;
            end
            else  {
{ENDIF}   {
            begin
              FScreenRect.Left := 0;
              FScreenRect.Top := 0;
              FScreenRect.Right := Screen.Width;
              FScreenRect.Bottom := Screen.Height;
            end;
          end;

          vd.Reduce16bit := Reduce16bit;
          vd.Reduce32bit := Reduce32bit;
          vd.LowReduce16bit := LowReduce16bit;
          vd.LowReduce32bit := LowReduce32bit;
          vd.LowReduceColors := LowReducedColors;
          vd.LowReduceType := LowReduceType;
          vd.LowReduceColorPercent := LowReduceColorPercent;

          m_BackBm.Width := FScreenRect.Right - FScreenRect.Left;
          m_BackBm.Height := FScreenRect.Bottom - FScreenRect.Top;
            }
{IFDEF MULTIMON}
          {if MultiMonitor then
          begin
            fixed.Left := FScreenRect.Left - Screen.DesktopLeft;
            fixed.Top := FScreenRect.Top - Screen.DesktopTop;
            fixed.Right := FScreenRect.Right - Screen.DesktopLeft;
            fixed.Bottom := FScreenRect.Bottom - Screen.DesktopTop;
          end
          else }
{ENDIF}
            {fixed := FScreenRect;

          vd.SetRegion(fixed);
        end
        else
        begin
          vd.Free;
          vd := nil;
        end;
      end;
    end
    else
    begin
      if assigned(m_BackBm) then
      begin
        vd.Free;
        vd := nil;
        m_BackBm.Free;
        m_BackBm := nil;
      end;
    end;
  end;
end;
             }
{?? ResolutionChanged??}
{
function TRtcScreenCapture.ScreenChanged: boolean;
Var
  _ScreenWidth, _ScreenHeight, _ScreenLeft, _ScreenTop: integer;

  r: TRect;
  DW: HWND;
  SDC: HDC;

begin
  SwitchToActiveDesktop;
 }
{IFDEF MULTIMON}
 { if MultiMonitor then
    r := Screen.DesktopRect
  else }
{ENDIF}
  {begin
    DW := GetCaptureWindow;
    try
      SDC := GetDC(DW);
    except
      SDC := 0;
    end;
    if (DW <> 0) and (SDC = 0) then
    begin
      DW := 0;
      try
        SDC := GetDC(DW);
      except
        SDC := 0;
      end;
      if SDC = 0 then
      begin
        Result := False;
        Exit;
      end;
    end;
    GetWindowRect(DW, r);
    ReleaseDC(DW, SDC);
  end;

  _ScreenLeft := r.Left;
  _ScreenTop := r.Top;
  _ScreenWidth := r.Right - r.Left;
  _ScreenHeight := r.Bottom - r.Top;

  Result := (FScreenWidth <> _ScreenWidth) or (FScreenHeight <> _ScreenHeight)
    or (FScreenLeft <> _ScreenLeft) or (FScreenTop <> _ScreenTop);

  if Result then
  begin
    MirageDriver := False;
    Sleep(1000);
    MirageDriver := True;
    Init;
  end;
end;
   }
{
function TRtcScreenCapture.GrabImageIncremental: TRtcRecord;
begin
  dfm_urgn.StartAdd;
  vd.UpdateIncremental(dfm_DstStride, dfm_urgn, dfm_ImgLine0);
  Result := dfm_urgn.CaptureRgnDelta(vd, dfm_DstStride, dfm_ImgLine0);
end;

function TRtcScreenCapture.GrabImageFullscreen: TRtcRecord;
begin
  dfm_ImgLine0 := PAnsiChar(m_BackBm.ScanLine[0]);
  dfm_DstStride := -ScaleByPixformat(m_BackBm.Width, m_BackBm.PixelFormat);

  dfm_fixed.Left := FScreenRect.Left - FScreenLeft;
  dfm_fixed.Top := FScreenRect.Top - FScreenTop;
  dfm_fixed.Right := FScreenRect.Right - FScreenLeft;
  dfm_fixed.Bottom := FScreenRect.Bottom - FScreenTop;

  if not assigned(dfm_urgn) then
  begin
    dfm_urgn := TGridUpdRegion.Create;
    dfm_urgn.SetScrRect(dfm_fixed);

    dfm_urgn.ScanStep := FScreenBlockCount;
    if dfm_urgn.ScanStep < 1 then
      dfm_urgn.ScanStep := 1
    else if dfm_urgn.ScanStep > 12 then
      dfm_urgn.ScanStep := 12;

    dfm_urgn.ScanStep2 := FScreen2BlockCount;
    if dfm_urgn.ScanStep2 < 1 then
      dfm_urgn.ScanStep2 := 1
    else if dfm_urgn.ScanStep2 > 12 then
      dfm_urgn.ScanStep2 := 12;

    dfm_urgn.Scan2Delay := FScreen2Delay;

    if FMaxTotalSize > 0 then
      dfm_urgn.MaxSize := FMaxTotalSize
    else
      dfm_urgn.MaxSize := 0;
  end;

  dfm_urgn.StartAdd;
  dfm_urgn.AddRect(dfm_fixed);
  vd.UpdateIncremental(dfm_DstStride, dfm_urgn, dfm_ImgLine0);

  Result := dfm_urgn.CaptureRgnNormal(vd, dfm_DstStride, dfm_ImgLine0);
  with Result.newRecord('res') do
  begin
    asInteger['Width'] := m_BackBm.Width;
    asInteger['Height'] := m_BackBm.Height;
    asInteger['Bits'] := vd.BitsPerPixel;
    asInteger['Bytes'] := vd.BytesPerPixel;
  end;
end;

function TRtcScreenCapture.GrabImageOldScreen: TRtcRecord;
var
  urgn: TGridUpdRegion;
begin
  urgn := TGridUpdRegion.Create;
  urgn.SetScrRect(dfm_fixed);
  urgn.StartAdd;
  urgn.AddRect(dfm_fixed);

  Result := urgn.CaptureRgnOld(vd, dfm_DstStride, dfm_ImgLine0);
  with Result.newRecord('res') do
  begin
    asInteger['Width'] := m_BackBm.Width;
    asInteger['Height'] := m_BackBm.Height;
    asInteger['Bits'] := vd.BitsPerPixel;
    asInteger['Bytes'] := vd.BytesPerPixel;
  end;

  urgn.Free;
end;
 }

procedure TRtcScreenCapture.GrabMouse;
var
  ci: TCursorInfo;
  icinfo: TIconInfo;
  pt: TPoint;
  i: integer;
begin
  ci.cbSize := SizeOf(ci);
  if Get_CursorInfo(ci) then
  begin
    if ci.flags = CURSOR_SHOWING then
    begin
      FMouseVisible := True;
      if FMouseInit or (ci.ptScreenPos.X <> FMouseX) or
        (ci.ptScreenPos.Y <> FMouseY) then
      begin
        FMouseMoved := True;
        FMouseX := ci.ptScreenPos.X;
        FMouseY := ci.ptScreenPos.Y;

        if (FLastMouseUser <> '') and (FMouseX = FLastMouseX) and
          (FMouseY = FLastMouseY) then
          FMouseUser := FLastMouseUser
        else
          FMouseUser := '';
      end;
      if FMouseInit or (ci.hCursor <> FMouseHandle) then
      begin
        FMouseChangedShape := True;
        FMouseHandle := ci.hCursor;
        if assigned(FMouseIcon) then
        begin
          FMouseIcon.Free;
          FMouseIcon := nil;
        end;
        if assigned(FMouseIconMask) then
        begin
          FMouseIconMask.Free;
          FMouseIconMask := nil;
        end;
        FMouseShape := 1;
        for i := crSizeAll to crDefault do
          if ci.hCursor = Screen.Cursors[i] then
          begin
            FMouseShape := i;
            Break;
          end;
        if FMouseShape = 1 then
        begin
          // send cursor image only for non-standard shapes
          if GetIconInfo(ci.hCursor, icinfo) then
          begin
            FMouseHotX := icinfo.xHotspot;
            FMouseHotY := icinfo.yHotspot;

            if icinfo.hbmMask <> INVALID_HANDLE_VALUE then
            begin
              FMouseIconMask := TBitmap.Create;
              FMouseIconMask.Handle := icinfo.hbmMask;
              FMouseIconMask.PixelFormat := pf4bit;
            end;

            if icinfo.hbmColor <> INVALID_HANDLE_VALUE then
            begin
              FMouseIcon := TBitmap.Create;
              FMouseIcon.Handle := icinfo.hbmColor;
              case FBPPLimit of
                0:
                  if FMouseIcon.PixelFormat > pf4bit then
                    FMouseIcon.PixelFormat := pf4bit;
                1:
                  if FMouseIcon.PixelFormat > pf8bit then
                    FMouseIcon.PixelFormat := pf8bit;
                2:
                  if FMouseIcon.PixelFormat > pf16bit then
                    FMouseIcon.PixelFormat := pf16bit;
              end;
            end;
          end;
        end;
      end;
      FMouseInit := False;
    end
    else
      FMouseVisible := False;
  end
  else if GetCursorPos(pt) then
  begin
    FMouseVisible := True;
    if FMouseInit or (pt.X <> FMouseX) or (pt.Y <> FMouseY) then
    begin
      FMouseMoved := True;
      FMouseX := pt.X;
      FMouseY := pt.Y;
      if (FLastMouseUser <> '') and (FMouseX = FLastMouseX) and
        (FMouseY = FLastMouseY) then
        FMouseUser := FLastMouseUser
      else
        FMouseUser := '';
    end;
    FMouseInit := False;
  end
  else
    FMouseVisible := False;
end;

function TRtcScreenCapture.GetMouseDelta: RtcString;
var
  rec: TRtcRecord;
begin
  if FMouseMoved or FMouseChangedShape or (FMouseLastVisible <> FMouseVisible)
  then
  begin
    rec := TRtcRecord.Create;
    try
      if FMouseLastVisible <> FMouseVisible then
        rec.asBoolean['V'] := FMouseVisible;
      if FMouseMoved then
      begin
        rec.asInteger['X'] := FMouseX - FScreenRect.Left;
        rec.asInteger['Y'] := FMouseY - FScreenRect.Top;
        if FMouseUser <> '' then
          rec.asText['U'] := FMouseUser;
      end;
      if FMouseChangedShape then
      begin
        if FMouseShape <= 0 then
          rec.asInteger['C'] := -FMouseShape // 0 .. -22  ->>  0 .. 22
        else
        begin
          rec.asInteger['HX'] := FMouseHotX;
          rec.asInteger['HY'] := FMouseHotY;
          if FMouseIcon <> nil then
            FMouseIcon.SaveToStream(rec.newByteStream('I'));
          if FMouseIconMask <> nil then
            FMouseIconMask.SaveToStream(rec.newByteStream('M'));
        end;
      end;
      Result := rec.toCode;
    finally
      rec.Free;
    end;
    FMouseMoved := False;
    FMouseChangedShape := False;
    FMouseLastVisible := FMouseVisible;
  end;
end;

function TRtcScreenCapture.GetMouse: RtcString;
begin
  FMouseChangedShape := True;
  FMouseMoved := True;
  FMouseLastVisible := not FMouseVisible;
  Result := GetMouseDelta;
end;

function IsMyHandle(a: HWND): TForm;
var
  i, cnt: integer;
begin
  Result := nil;
  cnt := Screen.FormCount;
  for i := 0 to cnt - 1 do
    if Screen.Forms[i].Handle = a then
    begin
      Result := Screen.Forms[i];
      Break;
    end;
end;

function okToClick(X, Y: integer): boolean;
var
  P: TPoint;
  W: HWND;
  hit: integer;
begin
  P.X := X;
  P.Y := Y;
  W := WindowFromPoint(P);
  if IsMyHandle(W) <> nil then
  begin
    hit := SendMessage(W, WM_NCHITTEST, 0, P.X + (P.Y shl 16));
    Result := not(hit in [HTCLOSE, HTMAXBUTTON, HTMINBUTTON]);
  end
  else
    Result := True;
end;

function okToUnClick(X, Y: integer): boolean;
var
  P: TPoint;
  W: HWND;
  hit: integer;
  frm: TForm;
begin
  P.X := X;
  P.Y := Y;
  W := WindowFromPoint(P);
  frm := IsMyHandle(W);
  if assigned(frm) then
  begin
    hit := SendMessage(W, WM_NCHITTEST, 0, P.X + (P.Y shl 16));
    Result := not(hit in [HTCLOSE, HTMAXBUTTON, HTMINBUTTON]);
    if not Result then
    begin
      case hit of
        HTCLOSE:
          PostMessage(W, WM_SYSCOMMAND, SC_CLOSE, 0);
        HTMINBUTTON:
          PostMessage(W, WM_SYSCOMMAND, SC_MINIMIZE, 0);
        HTMAXBUTTON:
          if frm.WindowState = wsMaximized then
            PostMessage(W, WM_SYSCOMMAND, SC_RESTORE, 0)
          else
            PostMessage(W, WM_SYSCOMMAND, SC_MAXIMIZE, 0);
      end;
    end;
  end
  else
    Result := True;
end;

procedure TRtcScreenCapture.Post_MouseDown(Button: TMouseButton);
begin
{$IFDEF KMDriver}
  if FMouseDriver and (FMouseAInit > 0) then
  begin
    case Button of
      mbLeft:
        MouseAInf.MouseAImitationLButtonDown;
      mbRight:
        MouseAInf.MouseAImitationRButtonDown;
      mbMiddle:
        mouse_event(MOUSEEVENTF_MIDDLEDOWN, 0, 0, 0, 0);
    end;
  end
  else
{$ENDIF}
    case Button of
      mbLeft:
        mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
      mbRight:
        mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0);
      mbMiddle:
        mouse_event(MOUSEEVENTF_MIDDLEDOWN, 0, 0, 0, 0);
    end;
end;

procedure TRtcScreenCapture.Post_MouseUp(Button: TMouseButton);
begin
{$IFDEF KMDriver}
  if FMouseDriver and (FMouseAInit > 0) then
  begin
    case Button of
      mbLeft:
        MouseAInf.MouseAImitationLButtonUp;
      mbRight:
        MouseAInf.MouseAImitationRButtonUp;
      mbMiddle:
        mouse_event(MOUSEEVENTF_MIDDLEDOWN, 0, 0, 0, 0);
    end;
  end
  else
{$ENDIF}
    case Button of
      mbLeft:
        mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
      mbRight:
        mouse_event(MOUSEEVENTF_RIGHTUP, 0, 0, 0, 0);
      mbMiddle:
        mouse_event(MOUSEEVENTF_MIDDLEUP, 0, 0, 0, 0);
    end;
end;

procedure TRtcScreenCapture.Post_MouseWheel(Wheel: integer);
begin
  mouse_event(MOUSEEVENTF_WHEEL, 0, 0, Wheel, 0);
end;

procedure TRtcScreenCapture.Post_MouseMove(X, Y: integer);
begin
{$IFDEF KMDriver}
  if FMouseDriver and (FMouseAInit > 0) then
  begin
    if (X > Screen.DesktopRect.Right) or (X < Screen.DesktopRect.Left) or
      (Y > Screen.DesktopRect.Bottom) or (Y < Screen.DesktopRect.Top) then
      Exit;

    if ScreenRect.Width > 0 then
    begin
      MouseAInf.MouseAImitationMove(mfMOUSE_MOVE_ABSOLUTE,
        MouseAInf.MouseXYToScreen(Point(X, Y)));
    end
    else
      SetCursorPos(X, Y);
  end
  else
{$ENDIF}
    if ScreenRect.Width > 0 then
    begin
      X := round(X / (Screen.Width - 1) * 65535);
      Y := round(Y / (Screen.Height - 1) * 65535);
      mouse_event(MOUSEEVENTF_MOVE or MOUSEEVENTF_ABSOLUTE, X, Y, 0, 0);
    end
    else
      SetCursorPos(X, Y);
end;

procedure PostMouseMessage(Msg:Cardinal; MouseX, MouseY: integer);
  var
    hdl,chdl:HWND;
    wpt,pt:TPoint;
    r:TRect;
  begin
  pt.X:=MouseX;
  pt.Y:=MouseY;
  wpt:=pt;
  if RtcMouseWindowHdl=0 then
    hdl:=WindowFromPoint(pt)
  else
    begin
    hdl:=RtcMouseWindowHdl;
    if IsWindow(hdl) then
      begin
      GetWindowRect(hdl,r);
      repeat
        pt.X:=wpt.X-r.Left;
        pt.Y:=wpt.Y-r.Top;
        chdl:=ChildWindowFromPointEx(hdl,pt,1+4);
        if not IsWindow(chdl) then
          Break
        else if chdl=hdl then
          Break
        else
          begin
          GetWindowRect(chdl,r);
          if (wpt.x>=r.left) and (wpt.x<=r.right) and
             (wpt.y>=r.top) and (wpt.y<=r.bottom) then
            hdl:=chdl
          else
            Break;
          end;
        until False;
      end;
    end;
  if IsWindow(hdl) then
    begin
    GetWindowRect(hdl,r);
    pt.x:=wpt.X-r.left;
    pt.y:=wpt.Y-r.Top;
    PostMessageA(hdl,msg,0,MakeLong(pt.X,pt.Y));
    end;
  end;

procedure TRtcScreenCapture.MouseDown(const user: string; X, Y: integer;
  Button: TMouseButton);
  var
    pt:TPoint;
begin
  FLastMouseUser := user;
  FLastMouseX := X + FScreenRect.Left;
  FLastMouseY := Y + FScreenRect.Top;

  if Button in [mbLeft, mbRight] then
    if GetSystemMetrics(SM_SWAPBUTTON) <> 0 then
      case Button of
        mbLeft:
          Button := mbRight;
        mbRight:
          Button := mbLeft;
      end;

  if RtcMouseControlMode=eventMouseControl then
    begin
    Post_MouseMove(FLastMouseX, FLastMouseY);
    if Button <> mbLeft then
      Post_MouseDown(Button)
    else if okToClick(FLastMouseX, FLastMouseY) then
      Post_MouseDown(Button);
    end
  else
    begin
    case Button of
      mbLeft: PostMouseMessage(WM_LBUTTONDOWN,pt.X,pt.Y);
      mbRight: PostMouseMessage(WM_RBUTTONDOWN,pt.X,pt.Y);
      mbMiddle: PostMouseMessage(WM_MBUTTONDOWN,pt.X,pt.Y);
      end;
    end;
end;

procedure TRtcScreenCapture.MouseUp(const user: string; X, Y: integer;
  Button: TMouseButton);
  var
    pt:TPoint;
begin
  FLastMouseUser := user;
  FLastMouseX := X + FScreenRect.Left;
  FLastMouseY := Y + FScreenRect.Top;

  if Button in [mbLeft, mbRight] then
    if GetSystemMetrics(SM_SWAPBUTTON) <> 0 then
      case Button of
        mbLeft:
          Button := mbRight;
        mbRight:
          Button := mbLeft;
      end;

  if RtcMouseControlMode=eventMouseControl then
    begin
    Post_MouseMove(FLastMouseX, FLastMouseY);
    if Button <> mbLeft then
      Post_MouseUp(Button)
    else if okToUnClick(FLastMouseX, FLastMouseY) then
      Post_MouseUp(Button);
    end
  else
    begin
    case Button of
      mbLeft: PostMouseMessage(WM_LBUTTONUP,pt.X,pt.Y);
      mbRight: PostMouseMessage(WM_RBUTTONUP,pt.X,pt.Y);
      mbMiddle: PostMouseMessage(WM_MBUTTONUP,pt.X,pt.Y);
      end;
    end;
end;

procedure TRtcScreenCapture.MouseMove(const user: String; X, Y: integer);
begin
  if RtcMouseControlMode=eventMouseControl then
    begin
    FLastMouseUser := user;
    FLastMouseX := X + FScreenRect.Left;
    FLastMouseY := Y + FScreenRect.Top;

    Post_MouseMove(FLastMouseX, FLastMouseY);
    end;
end;

procedure TRtcScreenCapture.MouseWheel(Wheel: integer);
begin
  if RtcMouseControlMode=eventMouseControl then
    Post_MouseWheel(Wheel);
end;

procedure TRtcScreenCapture.keybdevent(key: word; Down: boolean = True);
var
  vk: integer;
begin
  vk := MapVirtualKey(key, 0);
  if Down then
    keybd_event(key, vk, 0, 0)
  else
    keybd_event(key, vk, KEYEVENTF_KEYUP, 0);
end;

procedure TRtcScreenCapture.KeyDown(key: word; Shift: TShiftState);
var
  numlock: boolean;
begin
  case key of
    VK_SHIFT:
      if FShiftDown then
        Exit
      else
        FShiftDown := True;
    VK_CONTROL:
      if FCtrlDown then
        Exit
      else
        FCtrlDown := True;
    VK_MENU:
      if FAltDown then
        Exit
      else
        FAltDown := True;
  end;

  if (Key >= $21) and (Key <= $2E) then
  begin
    numlock := (GetKeyState(VK_NUMLOCK) and 1 = 1);
    if numlock then
    begin
      keybdevent(VK_NUMLOCK);
      keybdevent(VK_NUMLOCK, False);
    end;
    keybd_event(key,MapVirtualKey(key, 0), KEYEVENTF_EXTENDEDKEY, 0) // have to be Exctended ScanCodes
  end
  else
  begin    
    numlock := False;
    keybdevent(Key);
  end; 

  if numlock then
  begin
    keybdevent(VK_NUMLOCK, False);
    keybdevent(VK_NUMLOCK);
  end;
end;

procedure TRtcScreenCapture.KeyUp(key: word; Shift: TShiftState);
var
  numlock: boolean;
begin
  case key of
    VK_SHIFT:
      if not FShiftDown then
        Exit
      else
        FShiftDown := False;
    VK_CONTROL:
      if not FCtrlDown then
        Exit
      else
        FCtrlDown := False;
    VK_MENU:
      if not FAltDown then
        Exit
      else
        FAltDown := False;
  end;

  if (key >= $21) and (key <= $2E) then
  begin
    numlock := (GetKeyState(VK_NUMLOCK) and 1 = 1);
    if numlock then
    begin
      // turn NUM LOCK off
      keybdevent(VK_NUMLOCK);
      keybdevent(VK_NUMLOCK, False);
    end;
  end
  else
    numlock := False;

  keybdevent(key, False);

  if numlock then
  begin
    // turn NUM LOCK on
    keybdevent(VK_NUMLOCK);
    keybdevent(VK_NUMLOCK, False);
  end;
end;

procedure TRtcScreenCapture.SetKeys(capslock, lWithShift, lWithCtrl,
  lWithAlt: boolean);
begin
  if capslock then
  begin
    // turn CAPS LOCK off
    keybdevent(VK_CAPITAL);
    keybdevent(VK_CAPITAL, False);
  end;

  if lWithShift <> FShiftDown then
    keybdevent(VK_SHIFT, lWithShift);

  if lWithCtrl <> FCtrlDown then
    keybdevent(VK_CONTROL, lWithCtrl);

  if lWithAlt <> FAltDown then
    keybdevent(VK_MENU, lWithAlt);
end;

procedure TRtcScreenCapture.ResetKeys(capslock, lWithShift, lWithCtrl,
  lWithAlt: boolean);
begin
  if lWithAlt <> FAltDown then
    keybdevent(VK_MENU, FAltDown);

  if lWithCtrl <> FCtrlDown then
    keybdevent(VK_CONTROL, FCtrlDown);

  if lWithShift <> FShiftDown then
    keybdevent(VK_SHIFT, FShiftDown);

  if capslock then
  begin
    // turn CAPS LOCK on
    keybdevent(VK_CAPITAL);
    keybdevent(VK_CAPITAL, False);
  end;
end;

procedure TRtcScreenCapture.KeyPress(const AText: RtcString; AKey: word);
var
  a: integer;
  lScanCode: Smallint;
  lWithAlt, lWithCtrl, lWithShift: boolean;
  capslock: boolean;
begin
  for a := 1 to length(AText) do
  begin
{$IFDEF RTC_BYTESTRING}
    lScanCode := VkKeyScanA(AText[a]);
{$ELSE}
    lScanCode := VkKeyScanW(AText[a]);
{$ENDIF}
    if lScanCode = -1 then
    begin
      if not(AKey in [VK_MENU, VK_SHIFT, VK_CONTROL, VK_CAPITAL, VK_NUMLOCK])
      then
      begin
        keybdevent(AKey);
        keybdevent(AKey, False);
      end;
    end
    else
    begin
      lWithShift := lScanCode and $100 <> 0;
      lWithCtrl := lScanCode and $200 <> 0;
      lWithAlt := lScanCode and $400 <> 0;

      lScanCode := lScanCode and $F8FF;
      // remove Shift, Ctrl and Alt from the scan code

      capslock := GetKeyState(VK_CAPITAL) > 0;

      SetKeys(capslock, lWithShift, lWithCtrl, lWithAlt);

      keybdevent(lScanCode);
      keybdevent(lScanCode, False);

      ResetKeys(capslock, lWithShift, lWithCtrl, lWithAlt);
    end;
  end;
end;

procedure TRtcScreenCapture.KeyPressW(const AText: WideString; AKey: word);
var
  a: integer;
  lScanCode: Smallint;
  lWithAlt, lWithCtrl, lWithShift: boolean;
  capslock: boolean;
begin
  for a := 1 to length(AText) do
  begin
    lScanCode := VkKeyScanW(AText[a]);

    if lScanCode = -1 then
    begin
      if not(AKey in [VK_MENU, VK_SHIFT, VK_CONTROL, VK_CAPITAL, VK_NUMLOCK])
      then
      begin
        keybdevent(AKey);
        keybdevent(AKey, False);
      end;
    end
    else
    begin
      lWithShift := lScanCode and $100 <> 0;
      lWithCtrl := lScanCode and $200 <> 0;
      lWithAlt := lScanCode and $400 <> 0;

      lScanCode := lScanCode and $F8FF;
      // remove Shift, Ctrl and Alt from the scan code

      capslock := GetKeyState(VK_CAPITAL) > 0;

      SetKeys(capslock, lWithShift, lWithCtrl, lWithAlt);

      keybdevent(lScanCode);
      keybdevent(lScanCode, False);

      ResetKeys(capslock, lWithShift, lWithCtrl, lWithAlt);
    end;
  end;
end;

procedure TRtcScreenCapture.LWinKey(key: word);
begin
  SetKeys(False, False, False, False);
  keybdevent(VK_LWIN);
  keybdevent(key);
  keybdevent(key, False);
  keybdevent(VK_LWIN, False);
  ResetKeys(False, False, False, False);
end;

procedure TRtcScreenCapture.RWinKey(key: word);
begin
  SetKeys(False, False, False, False);
  keybdevent(VK_RWIN);
  keybdevent(key);
  keybdevent(key, False);
  keybdevent(VK_RWIN, False);
  ResetKeys(False, False, False, False);
end;

procedure TRtcScreenCapture.SpecialKey(const AKey: RtcString);
var
  capslock: boolean;
begin
  capslock := GetKeyState(VK_CAPITAL) > 0;

  if AKey = 'CAD' then
  begin
    // Ctrl+Alt+Del
    if UpperCase(Get_UserName) = 'SYSTEM' then
    begin
      XLog('Executing CtrlAltDel as SYSTEM user ...');
      SetKeys(capslock, False, False, False);
      if not Post_CtrlAltDel then
        begin
        XLog('CtrlAltDel execution failed as SYSTEM user');
        if rtcGetProcessID(AppFileName) > 0 then
          begin
          XLog('Sending CtrlAltDel request to Host Service ...');
          Write_File(ChangeFileExt(AppFileName, '.cad'), '');
          end;
        end
      else
        XLog('CtrlAltDel execution successful');
      ResetKeys(capslock, False, False, False);
    end
    else
    begin
      if rtcGetProcessID(AppFileName) > 0 then
        begin
        XLog('Sending CtrlAltDel request to Host Service ...');
        Write_File(ChangeFileExt(AppFileName, '.cad'), '');
        end
      else
        begin
        XLog('Emulating CtrlAltDel as "'+Get_UserName+'" user ...');
        SetKeys(capslock, False, True, True);
        keybdevent(VK_ESCAPE);
        keybdevent(VK_ESCAPE, False);
        ResetKeys(capslock, False, True, True);
        end;
    end;
  end
  else if AKey = 'COPY' then
  begin
    // Ctrl+C
    SetKeys(capslock, False, True, False);
    keybdevent(Ord('C'));
    keybdevent(Ord('C'), False);
    ResetKeys(capslock, False, True, False);
  end
  else if AKey = 'AT' then
  begin
    // Alt+Tab
    SetKeys(capslock, False, False, True);
    keybdevent(VK_TAB);
    keybdevent(VK_TAB, False);
    ResetKeys(capslock, False, False, True);
  end
  else if AKey = 'SAT' then
  begin
    // Shift+Alt+Tab
    SetKeys(capslock, True, False, True);
    keybdevent(VK_TAB);
    keybdevent(VK_TAB, False);
    ResetKeys(capslock, True, False, True);
  end
  else if AKey = 'CAT' then
  begin
    // Ctrl+Alt+Tab
    SetKeys(capslock, False, True, True);
    keybdevent(VK_TAB);
    keybdevent(VK_TAB, False);
    ResetKeys(capslock, False, True, True);
  end
  else if AKey = 'SCAT' then
  begin
    // Shift+Ctrl+Alt+Tab
    SetKeys(capslock, True, True, True);
    keybdevent(VK_TAB);
    keybdevent(VK_TAB, False);
    ResetKeys(capslock, True, True, True);
  end
  else if AKey = 'WIN' then
  begin
    // Windows
    SetKeys(capslock, False, False, False);
    keybdevent(VK_LWIN);
    keybdevent(VK_LWIN, False);
    ResetKeys(capslock, False, False, False);
  end
  else if AKey = 'RWIN' then
  begin
    // Windows
    SetKeys(capslock, False, False, False);
    keybdevent(VK_RWIN);
    keybdevent(VK_RWIN, False);
    ResetKeys(capslock, False, False, False);
  end
  else if AKey = 'HDESK' then
  begin
    // Hide Wallpaper
    Hide_Wallpaper;
  end
  else if AKey = 'SDESK' then
  begin
    // Show Wallpaper
    Show_Wallpaper;
  end;
end;

procedure TRtcScreenCapture.ReleaseAllKeys;
begin
  if FShiftDown then
    KeyUp(VK_SHIFT, []);
  if FAltDown then
    KeyUp(VK_MENU, []);
  if FCtrlDown then
    KeyUp(VK_CONTROL, []);
end;
{
function TRtcScreenCapture.GetHaveScreen: Boolean;
begin
  Result := FPDesktopHost.FHaveScreen;
end;
procedure TRtcScreenCapture.SetHaveScreen(const Value: Boolean);
begin
  if FPDesktopHost.FHaveScreen <> Value then
  begin
    FPDesktopHost.FHaveScreen := Value;
    if Assigned(FPDesktopHost.FOnHaveScreeenChanged) then
      FPDesktopHost.FOnHaveScreeenChanged(Self);
  end;
end;
 }
procedure TRtcScreenCapture.SetMultiMon(const Value: boolean);
begin
{$IFDEF MULTIMON}
  if FMultiMon <> Value then
  begin
    FMultiMon := Value;
  end;
{$ENDIF}
end;


initialization

if not IsWinNT then
  RTC_CAPTUREBLT := 0;

end.
